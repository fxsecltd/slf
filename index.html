<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self Liquidity Farm</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <style>
        :root {
            --primary: #4e44ce;
            --secondary: #2a2a72;
            --accent: #00d2ff;
            --text: #333;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--light);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px 0;
            text-align: center;
            border-bottom: 4px solid var(--accent);
        }
        
        .language-toggle {
            text-align: right;
            padding: 10px;
        }
        
        .language-toggle a {
            color: white;
            text-decoration: none;
            margin: 0 10px;
            font-weight: bold;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        h2 {
            color: var(--primary);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
        }
        
        .wallet-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .wallet-connect {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #walletAddress {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: var(--secondary);
        }
        
        .btn-connect {
            background-color: var(--success);
        }
        
        .btn-disconnect {
            background-color: var(--danger);
        }
        
        .btn-paste {
            background-color: var(--accent);
            margin-left: 10px;
            padding: 10px;
        }
        
        .price-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .price-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .price-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
        }
        
        .transaction-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .transaction-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .btn-buy {
            background-color: var(--success);
        }
        
        .btn-sell {
            background-color: var(--danger);
        }
        
        .user-balance {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .balance-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            background-color: var(--dark);
            color: white;
            margin-top: 40px;
        }
        
        .hidden {
            display: none;
        }
        
        #walletAddress[readonly] {
            background-color: #f0f0f0;
            cursor: not-allowed;
        }
        
        @media (max-width: 768px) {
            .price-info, .transaction-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="language-toggle">
            <a href="#" id="lang-en">English</a>
            <a href="#" id="lang-ru">Русский</a>
        </div>
        <div class="container">
            <h1 id="main-title">Self Liquidity Farm</h1>
            <p id="main-subtitle">An innovative wrapped ETH alternative with dynamic pricing</p>
        </div>
    </header>

    <div class="container">
        <section class="wallet-section">
            <h2 id="wallet-title">Wallet Connection</h2>
            <div class="wallet-connect">
                <input type="text" id="walletAddress" placeholder="Enter wallet address">
                <button id="pasteAddress" class="btn-paste">Paste</button>
                <button id="connectWallet" class="btn-connect">Connect MetaMask</button>
                <button id="disconnectWallet" class="btn-disconnect hidden">Disconnect</button>
            </div>
            <button id="addToMetaMask" class="hidden">Add SLF to MetaMask</button>
        </section>

        <section class="user-balance hidden" id="balanceSection">
            <h2 id="balance-title">Your Balance</h2>
            <div class="form-group">
                <label id="token-balance-label">SLF Token Balance:</label>
                <div class="balance-value" id="tokenBalance">0</div>
            </div>
            <div class="form-group">
                <label id="eth-value-label">Current ETH Value:</label>
                <div class="balance-value" id="ethValue">0 ETH</div>
            </div>
            <div class="form-group">
                <label>Wallet ETH Balance:</label>
                <div class="balance-value" id="walletEthBalance">0 ETH</div>
            </div>
        </section>

        <section class="price-info">
            <div class="price-card">
                <h3 id="buy-price-title">Current Buy Price</h3>
                <div class="price-value" id="buyPrice">Loading...</div>
                <p id="buy-price-desc">Price per token when purchasing</p>
            </div>
            <div class="price-card">
                <h3 id="sell-price-title">Current Sell Price</h3>
                <div class="price-value" id="sellPrice">Loading...</div>
                <p id="sell-price-desc">Price per token when selling back</p>
            </div>
        </section>

        <section class="transaction-section">
            <div class="transaction-card">
                <h3 id="buy-title">Buy SLF Tokens</h3>
                <div class="form-group">
                    <label for="buyEthAmount" id="eth-amount-label">ETH Amount:</label>
                    <input type="number" id="buyEthAmount" placeholder="Enter ETH amount" step="0.0001">
                </div>
                <div class="form-group">
                    <label for="buyTokenAmount" id="token-amount-label">SLF Tokens:</label>
                    <input type="number" id="buyTokenAmount" placeholder="Will be calculated" readonly>
                </div>
                <button id="btnBuy" class="btn-buy">Buy Tokens</button>
            </div>
            <div class="transaction-card">
                <h3 id="sell-title">Sell SLF Tokens</h3>
                <div class="form-group">
                    <label id="sell-info">Sell all your SLF tokens back to the contract</label>
                </div>
                <div class="form-group">
                    <label id="receive-eth-label">You will receive:</label>
                    <div class="price-value" id="receiveEth">0 ETH</div>
                </div>
                <button id="btnSell" class="btn-sell">Sell All Tokens</button>
            </div>
        </section>

        <section>
            <h2 id="about-title">About Self Liquidity Farm</h2>
            <div id="en-description">
                <p>Self Liquidity Farm (SLF) is an innovative wrapped ETH alternative with dynamic pricing mechanics:</p>
                <ul>
                    <li>Wrap any ETH amount (even micro amounts) to receive SLF tokens</li>
                    <li>Price increases 0.1% after each buy transaction</li>
                    <li>Price decreases 0.1% after each sell transaction</li>
                    <li>0.1% spread fee goes to contract owner</li>
                    <li>Flat 1 SLF token transfer fee for any transaction</li>
                    <li>Sell all tokens by sending 0 ETH to the contract</li>
                </ul>
                <p>The redemption price always equals the contract's ETH balance divided by total SLF supply, creating a self-regulating liquidity system.</p>
            </div>
            <div id="ru-description" class="hidden">
                <p>Self Liquidity Farm (SLF) - это инновационная альтернатива Wrapped ETH с динамическим ценообразованием:</p>
                <ul>
                    <li>Конвертируйте любое количество ETH (даже микро-суммы) в токены SLF</li>
                    <li>Цена увеличивается на 0.1% после каждой покупки</li>
                    <li>Цена уменьшается на 0.1% после каждой продажи</li>
                    <li>Комиссия 0.1% от спреда идет владельцу контракта</li>
                    <li>Фиксированная комиссия 1 SLF токен за любую передачу</li>
                    <li>Продажа всех токенов осуществляется отправкой 0 ETH в контракт</li>
                </ul>
                <p>Цена выкупа всегда равна балансу ETH в контракте, деленному на общее количество токенов, создавая саморегулируемую систему ликвидности.</p>
            </div>
        </section>
    </div>

    <footer>
        <p id="footer-text">© 2023 Self Liquidity Farm. All rights reserved.</p>
    </footer>

    <script>
        // Contract configuration
        const contractAddress = "0xBF7e09123b30e5CF33ee6097D879857cf3e04c9C";
        const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"asknow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bidnow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}];

        // Конфигурация RPC-провайдеров
        const RPC_PROVIDERS = [
            "https://eth.llamarpc.com",
            "https://1rpc.io/eth",
            "https://rpc.flashbots.net",
            "https://ethereum.publicnode.com",
            "https://eth-mainnet.g.alchemy.com/v2/demo"
        ];

        // Глобальные переменные
        let web3;
        let contract;
        let currentProviderIndex = 0;
        let userAddress = localStorage.getItem('slf_wallet') || '';
        let isManualMode = false;

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', async function() {
            console.log("Страница загружена, начинаем инициализацию...");
            
            // Восстанавливаем сохраненный адрес
            const walletInput = document.getElementById('walletAddress');
            if (userAddress) {
                walletInput.value = userAddress;
                if (localStorage.getItem('wallet_source') === 'metamask') {
                    walletInput.readOnly = true;
                }
            }

            // Пробуем автоматическое подключение
            await initWeb3();
            
            // Если есть сохраненный адрес, загружаем данные
            if (userAddress) {
                console.log("Обнаружен сохраненный адрес, загружаем данные...");
                await loadData();
            }
        });

        async function initWeb3() {
            console.log("Инициализация Web3...");
            
            // 1. Пробуем браузерный провайдер (MetaMask)
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    console.log("Успешно подключено через MetaMask");
                    return true;
                } catch (error) {
                    console.error("Ошибка MetaMask:", error);
                }
            }
            
            // 2. Пробуем публичные RPC
            const rpcConnected = await connectToPublicRPC();
            if (!rpcConnected) {
                alert("Не удалось подключиться к Ethereum сети. Пожалуйста, установите MetaMask или попробуйте позже.");
                return false;
            }
            return true;
        }

        async function connectToPublicRPC() {
            console.log("Попытка подключения к публичным RPC...");
            
            for (let i = 0; i < RPC_PROVIDERS.length; i++) {
                const providerUrl = RPC_PROVIDERS[i];
                try {
                    console.log(`Пробуем RPC: ${providerUrl}`);
                    const provider = new Web3.providers.HttpProvider(providerUrl, {
                        timeout: 5000 // 5 секунд таймаут
                    });
                    const testWeb3 = new Web3(provider);
                    
                    // Тестовый запрос с таймаутом
                    const blockNumber = await Promise.race([
                        testWeb3.eth.getBlockNumber(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), 5000)
                    )]);
                    
                    console.log(`Успешно подключено к ${providerUrl}, номер блока: ${blockNumber}`);
                    web3 = testWeb3;
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    return true;
                } catch (error) {
                    console.error(`Ошибка подключения к ${providerUrl}:`, error.message);
                    if (i === RPC_PROVIDERS.length - 1) {
                        console.error("Все RPC провайдеры недоступны");
                        return false;
                    }
                }
            }
        }

        // Подключение кошелька
        async function connectWallet() {
            console.log("Попытка подключения кошелька...");
            const walletInput = document.getElementById('walletAddress');
            const manualAddress = walletInput.value.trim();
            
            // Проверяем ручной ввод
            if (!isValidAddress(manualAddress)) {
                alert(translations[currentLang].invalidAddress);
                return;
            }
            
            // 1. Пробуем подключиться через MetaMask
            if (window.ethereum || window.web3?.givenProvider) {
                console.log("Обнаружен MetaMask, пробуем подключиться...");
                try {
                    if (!web3) await initWeb3();
                    
                    const accounts = await web3.eth.getAccounts();
                    userAddress = accounts.length > 0 ? accounts[0] : (await web3.eth.requestAccounts())[0];
                    
                    walletInput.value = userAddress;
                    walletInput.readOnly = true;
                    localStorage.setItem('slf_wallet', userAddress);
                    localStorage.setItem('wallet_source', 'metamask');
                    isManualMode = false;
                    
                    console.log("Успешно подключено через MetaMask, адрес:", userAddress);
                    updateUI();
                    await loadData();
                    return;
                } catch (error) {
                    console.error("Ошибка подключения MetaMask:", error);
                }
            }
            
            // 2. Режим ручного ввода
            console.log("Активация ручного режима для адреса:", manualAddress);
            userAddress = manualAddress;
            localStorage.setItem('slf_wallet', userAddress);
            localStorage.setItem('wallet_source', 'manual');
            isManualMode = true;
            
            // Инициализируем Web3, если еще не инициализирован
            if (!web3) {
                await initWeb3();
            }
            
            updateUI();
            alert(translations[currentLang].manualModeWarning);
            await loadData();
        }

        async function loadData() {
            if (!web3 || !contract) {
                console.error("Web3 или контракт не инициализированы");
                return;
            }

            try {
                // 1. Баланс ETH
                console.error("Запрос баланса эфириума");
                const ethBalance = await web3.eth.getBalance(userAddress);
                document.getElementById('walletEthBalance').textContent = 
                    web3.utils.fromWei(ethBalance, 'ether') + ' ETH';
                
                // 2. Баланс токенов
                console.error("Запрос баланса токенов");
                const tokenBalance = await contract.methods.balanceOf(userAddress).call();
                document.getElementById('tokenBalance').textContent = 
                    (tokenBalance / 1e6).toFixed(6);
                
                // 3. Цены
                console.error("Запрос текущих цен");
                const [buyPrice, sellPrice] = await Promise.all([
                    contract.methods.asknow().call(),
                    contract.methods.bidnow().call()
                ]);
                
                document.getElementById('buyPrice').textContent = 
                    web3.utils.fromWei(buyPrice, 'ether') + ' ETH';
                document.getElementById('sellPrice').textContent = 
                    web3.utils.fromWei(sellPrice, 'ether') + ' ETH';
                    
                // 4. Расчет выручки
                console.error("Расчет текущей стоимости при продаже");
                const sellValue = (BigInt(tokenBalance) * BigInt(sellPrice)) / BigInt(1e6);
                document.getElementById('ethValue').textContent = 
                    web3.utils.fromWei(sellValue.toString(), 'ether') + ' ETH';
                    
            } catch (error) {
                console.error("Ошибка загрузки данных:", error);
                alert("Ошибка получения данных. Подробности в консоли.");
            }
        }
        // Функция расчета суммы при продаже
        function calculateSellValue(tokenUnits, sellPricePerUnit) {
            // Умножаем количество минимальных единиц на цену продажи за единицу
            const weiAmount = BigInt(tokenUnits) * BigInt(sellPricePerUnit);
            return weiAmount.toString();
        }
        // Translations
        const translations = {
            en: {
                title: "Self Liquidity Farm",
                subtitle: "An innovative wrapped ETH alternative with dynamic pricing",
                walletTitle: "Wallet Connection",
                connect: "Connect MetaMask",
                disconnect: "Disconnect",
                addToMM: "Add SLF to MetaMask",
                balanceTitle: "Your Balance",
                tokenBalance: "SLF Token Balance:",
                ethValue: "Current ETH Value:",
                buyPriceTitle: "Current Buy Price",
                buyPriceDesc: "Price per token when purchasing",
                sellPriceTitle: "Current Sell Price",
                sellPriceDesc: "Price per token when selling back",
                buyTitle: "Buy SLF Tokens",
                ethAmount: "ETH Amount:",
                tokenAmount: "SLF Tokens:",
                buyBtn: "Buy Tokens",
                sellTitle: "Sell SLF Tokens",
                sellInfo: "Sell all your SLF tokens back to the contract",
                receiveEth: "You will receive:",
                sellBtn: "Sell All Tokens",
                aboutTitle: "About Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. All rights reserved.",
                noMetaMask: "MetaMask not detected. Please install or enable it.",
                manualModeWarning: "Manual mode activated. Some features may be limited.",
                invalidAddress: "Invalid Ethereum address format",
                pasteFailed: "Failed to paste address",
                transactionSent: "Transaction sent: ",
                transactionFailed: "Transaction failed",
                enterValidETH: "Please enter valid ETH amount"
            },
            ru: {
                title: "Self Liquidity Farm",
                subtitle: "Инновационная альтернатива Wrapped ETH с динамическим ценообразованием",
                walletTitle: "Подключение кошелька",
                connect: "Подключить MetaMask",
                disconnect: "Отключить",
                addToMM: "Добавить SLF в MetaMask",
                balanceTitle: "Ваш баланс",
                tokenBalance: "Баланс SLF токенов:",
                ethValue: "Текущая стоимость в ETH:",
                buyPriceTitle: "Текущая цена покупки",
                buyPriceDesc: "Цена за токен при покупке",
                sellPriceTitle: "Текущая цена продажи",
                sellPriceDesc: "Цена за токен при продаже",
                buyTitle: "Купить SLF токены",
                ethAmount: "Сумма в ETH:",
                tokenAmount: "SLF токены:",
                buyBtn: "Купить токены",
                sellTitle: "Продать SLF токены",
                sellInfo: "Продайте все ваши SLF токены обратно в контракт",
                receiveEth: "Вы получите:",
                sellBtn: "Продать все токены",
                aboutTitle: "О Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. Все права защищены.",
                noMetaMask: "MetaMask не обнаружен. Установите или включите расширение.",
                manualModeWarning: "Активирован ручной режим. Некоторые функции могут быть недоступны.",
                invalidAddress: "Неверный формат Ethereum-адреса",
                pasteFailed: "Ошибка вставки адреса",
                transactionSent: "Транзакция отправлена: ",
                transactionFailed: "Ошибка транзакции",
                enterValidETH: "Введите корректную сумму ETH"
            }
        };

        // Current language
        let currentLang = localStorage.getItem('slf_lang') || 'en';

        // Initialize language
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('slf_lang', lang);
            
            for (const [key, value] of Object.entries(translations[lang])) {
                const elements = document.querySelectorAll(`[id="${key}"]`);
                elements.forEach(el => {
                    if (el.tagName === 'INPUT' && el.placeholder) {
                        el.placeholder = value;
                    } else {
                        el.textContent = value;
                    }
                });
            }
            
            document.getElementById('en-description').classList.toggle('hidden', lang !== 'en');
            document.getElementById('ru-description').classList.toggle('hidden', lang !== 'ru');
        }

        // Check address validity
        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        async function initWeb3() {
            console.log("Инициализация Web3...");
            
            // 1. Пробуем браузерный провайдер (MetaMask)
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.enable();
                    console.log("Успешно подключено через MetaMask");
                    return true;
                } catch (error) {
                    console.error("Ошибка MetaMask:", error);
                }
            }
            
            // 2. Пробуем Legacy Web3 (старые версии MetaMask)
            if (window.web3?.givenProvider) {
                try {
                    web3 = new Web3(window.web3.givenProvider);
                    console.log("Успешно подключено через Legacy Web3");
                    return true;
                } catch (error) {
                    console.error("Ошибка Legacy Web3:", error);
                }
            }
            
            // 3. Пробуем публичные RPC
            console.log("Браузерный провайдер не найден, пробуем публичные RPC");
            return await connectToPublicRPC();
        }

        // Connect wallet
        async function connectWallet() {
            const walletInput = document.getElementById('walletAddress');
            const manualAddress = walletInput.value.trim();

            // MetaMask mode
            if (window.ethereum || window.web3?.givenProvider) {
                try {
                    if (!web3) await initWeb3();
                    
                    const accounts = await web3.eth.getAccounts();
                    userAddress = accounts.length > 0 ? accounts[0] : (await web3.eth.requestAccounts())[0];
                    
                    walletInput.value = userAddress;
                    walletInput.readOnly = true;
                    localStorage.setItem('slf_wallet', userAddress);
                    localStorage.setItem('wallet_source', 'metamask');
                    updateUI();
                    startDataRefresh();
                    return;
                } catch (error) {
                    console.error('MetaMask error:', error);
                }
            }

            // Manual mode
            if (isValidAddress(manualAddress)) {
                userAddress = manualAddress;
                localStorage.setItem('slf_wallet', userAddress);
                localStorage.setItem('wallet_source', 'manual');
                updateUI();
                alert(translations[currentLang].manualModeWarning);
                return;
            }

            alert(translations[currentLang].invalidAddress);
        }

        // Disconnect wallet
        function disconnectWallet() {
            userAddress = '';
            localStorage.removeItem('slf_wallet');
            localStorage.removeItem('wallet_source');
            
            const walletInput = document.getElementById('walletAddress');
            walletInput.value = '';
            walletInput.readOnly = false;
            
            document.getElementById('connectWallet').classList.remove('hidden');
            document.getElementById('disconnectWallet').classList.add('hidden');
            document.getElementById('addToMetaMask').classList.add('hidden');
            document.getElementById('balanceSection').classList.add('hidden');
            
            stopDataRefresh();
        }

        // Update UI
        function updateUI() {
            document.getElementById('connectWallet').classList.add('hidden');
            document.getElementById('disconnectWallet').classList.remove('hidden');
            document.getElementById('addToMetaMask').classList.remove('hidden');
            document.getElementById('balanceSection').classList.remove('hidden');
        }

        // Data refresh
        function startDataRefresh() {
            stopDataRefresh();
            loadData();
            refreshInterval = setInterval(loadData, 10000);
        }

        function stopDataRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // Format ETH values
        function formatETH(value) {
            if (!web3) return "0 ETH";
            return web3.utils.fromWei(value.toString(), 'ether') + ' ETH';
        }

        // Обновленная функция расчета количества токенов при покупке
        function updateTokenCalculation() {
            const buyEthInput = document.getElementById('buyEthAmount');
            const buyTokenInput = document.getElementById('buyTokenAmount');
            
            if (!buyEthInput.value || !web3 || !contract) return;
            
            try {
                const ethAmount = parseFloat(buyEthInput.value);
                if (isNaN(ethAmount) || ethAmount <= 0) return;
                
                // Получаем цену покупки (за 1 минимальную единицу)
                const buyPriceText = document.getElementById('buyPrice').textContent;
                const buyPricePerUnit = parseFloat(buyPriceText.split(' ')[0]);
                
                if (!isNaN(buyPricePerUnit)) {
                    // Конвертируем ETH в wei
                    const ethInWei = web3.utils.toWei(ethAmount.toString(), 'ether');
                    
                    // Рассчитываем количество минимальных единиц (целое число)
                    const units = Math.floor(parseInt(ethInWei) / buyPricePerUnit);
                    
                    // Конвертируем в токены (делим на 10^6)
                    const tokens = units / 1000000;
                    
                    buyTokenInput.value = tokens.toFixed(6);
                }
            } catch (error) {
                console.error('Calculation error:', error);
            }
        }

        // Новая функция для расчета ETH при продаже (будет вызываться при загрузке данных)
        function updateSellCalculation() {
            if (!web3 || !contract || !userAddress) return;
            
            try {
                const tokenBalanceElement = document.getElementById('tokenBalance');
                const tokenBalance = parseFloat(tokenBalanceElement.textContent);
                
                if (isNaN(tokenBalance) || tokenBalance <= 0) return;
                
                // Получаем цену продажи (за 1 минимальную единицу)
                const sellPriceText = document.getElementById('sellPrice').textContent;
                const sellPricePerUnit = parseFloat(sellPriceText.split(' ')[0]);
                
                if (!isNaN(sellPricePerUnit)) {
                    // Конвертируем токены в минимальные единицы
                    const units = tokenBalance * 1000000;
                    
                    // Рассчитываем сумму в wei
                    const weiAmount = units * sellPricePerUnit;
                    
                    // Конвертируем wei в ETH
                    const ethAmount = web3.utils.fromWei(weiAmount.toString(), 'ether');
                    
                    document.getElementById('receiveEth').textContent = parseFloat(ethAmount).toFixed(6) + ' ETH';
                }
            } catch (error) {
                console.error('Sell calculation error:', error);
            }
        }

        // Обновляем функцию loadData()
        async function loadData() {
            if (!contract || !userAddress) return;
            
            try {
                const [buyPricePerUnit, sellPricePerUnit, tokenBalanceUnits] = await Promise.all([
                    contract.methods.asknow().call(),
                    contract.methods.bidnow().call(),
                    contract.methods.balanceOf(userAddress).call()
                ]);
                
                // Форматируем цены (за 1 минимальную единицу)
                document.getElementById('buyPrice').textContent = formatETH(buyPricePerUnit);
                document.getElementById('sellPrice').textContent = formatETH(sellPricePerUnit);
                
                // Конвертируем баланс из минимальных единиц в токены
                const tokenBalance = tokenBalanceUnits / 1000000;
                document.getElementById('tokenBalance').textContent = tokenBalance.toFixed(6);
                
                // Обновляем расчет ETH при продаже
                updateSellCalculation();
                
                // Обновляем расчет токенов при покупке (если есть введенное значение)
                updateTokenCalculation();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // Модифицированная функция formatETH для отображения цен
        function formatETH(value) {
            if (!web3) return "0 ETH";
            const ethValue = web3.utils.fromWei(value.toString(), 'ether');
            return parseFloat(ethValue).toFixed(18) + ' ETH'; // Показываем полную точность
        }

        // Buy tokens
        document.getElementById('btnBuy').addEventListener('click', async () => {
            const ethAmount = parseFloat(document.getElementById('buyEthAmount').value);
            if (!ethAmount || ethAmount <= 0) {
                alert(translations[currentLang].enterValidETH);
                return;
            }
            
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: web3.utils.toHex(web3.utils.toWei(ethAmount.toString(), 'ether')),
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Sell tokens
        document.getElementById('btnSell').addEventListener('click', async () => {
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: '0x0',
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Paste address
        document.getElementById('pasteAddress').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (isValidAddress(text)) {
                    const walletInput = document.getElementById('walletAddress');
                    walletInput.value = text;
                    localStorage.setItem('slf_wallet', text);
                    localStorage.setItem('wallet_source', 'manual');
                } else {
                    alert(translations[currentLang].invalidAddress);
                }
            } catch (error) {
                console.error('Paste error:', error);
                alert(translations[currentLang].pasteFailed);
            }
        });

        // Language switchers
        document.getElementById('lang-en').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('en');
        });
        
        document.getElementById('lang-ru').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('ru');
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            setLanguage(currentLang);
            
            const walletInput = document.getElementById('walletAddress');
            if (userAddress) {
                walletInput.value = userAddress;
                if (localStorage.getItem('wallet_source') === 'metamask') {
                    walletInput.readOnly = true;
                }
            }

            if (localStorage.getItem('wallet_source') === 'metamask') {
                setTimeout(async () => {
                    if (window.ethereum || window.web3?.givenProvider) {
                        await initWeb3();
                        await connectWallet();
                    }
                }, 500);
            }

            // Input events
            document.getElementById('buyEthAmount').addEventListener('input', updateTokenCalculation);
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
        });
    </script>
</body>
</html>
