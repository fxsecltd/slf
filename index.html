<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net;
      style-src 'self' 'unsafe-inline';
      connect-src 'self' https://*.ethereum.org https://*.infura.io https://*.ankr.com;
      frame-src 'self' https://*.metamask.io;
    ">
    <title>Self Liquidity Farm</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.5.2/dist/web3.min.js"></script>
    <style>
        :root {
            --primary: #4e44ce;
            --secondary: #2a2a72;
            --accent: #00d2ff;
            --text: #333;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--light);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px 0;
            text-align: center;
            border-bottom: 4px solid var(--accent);
        }
        
        .language-toggle {
            text-align: right;
            padding: 10px;
        }
        
        .language-toggle a {
            color: white;
            text-decoration: none;
            margin: 0 10px;
            font-weight: bold;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        h2 {
            color: var(--primary);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
        }
        
        .wallet-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .wallet-connect {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #walletAddress {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: var(--secondary);
        }
        
        .btn-connect {
            background-color: var(--success);
        }
        
        .btn-disconnect {
            background-color: var(--danger);
        }
        
        .btn-paste {
            background-color: var(--accent);
            margin-left: 10px;
            padding: 10px;
        }
        
        .price-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .price-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .price-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
        }
        
        .transaction-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .transaction-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .btn-buy {
            background-color: var(--success);
        }
        
        .btn-sell {
            background-color: var(--danger);
        }
        
        .user-balance {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .balance-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            background-color: var(--dark);
            color: white;
            margin-top: 40px;
        }
        
        .hidden {
            display: none;
        }
        
        #walletAddress[readonly] {
            background-color: #f0f0f0;
            cursor: not-allowed;
        }
        
        @media (max-width: 768px) {
            .price-info, .transaction-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="language-toggle">
            <a href="#" id="lang-en">English</a>
            <a href="#" id="lang-ru">Русский</a>
        </div>
        <div class="container">
            <h1 id="main-title">Self Liquidity Farm</h1>
            <p id="main-subtitle">An innovative wrapped ETH alternative with dynamic pricing</p>
        </div>
    </header>

    <div class="container">
        <section class="wallet-section">
            <h2 id="wallet-title">Wallet Connection</h2>
            <div class="wallet-connect">
                <input type="text" id="walletAddress" placeholder="Enter wallet address">
                <button id="pasteAddress" class="btn-paste">Paste</button>
                <button id="connectWallet" class="btn-connect">Connect MetaMask</button>
                <button id="disconnectWallet" class="btn-disconnect hidden">Disconnect</button>
            </div>
            <button id="addToMetaMask" class="hidden">Add SLF to MetaMask</button>
        </section>

        <section class="user-balance hidden" id="balanceSection">
            <h2 id="balance-title">Your Balance</h2>
            <div class="form-group">
                <label id="token-balance-label">SLF Token Balance:</label>
                <div class="balance-value" id="tokenBalance">0</div>
            </div>
            <div class="form-group">
                <label id="eth-value-label">Current ETH Value:</label>
                <div class="balance-value" id="ethValue">0 ETH</div>
            </div>
            <div class="form-group">
                <label>Wallet ETH Balance:</label>
                <div class="balance-value" id="walletEthBalance">0 ETH</div>
            </div>
        </section>

        <section class="price-info">
            <div class="price-card">
                <h3 id="buy-price-title">Current Buy Price</h3>
                <div class="price-value" id="buyPrice">Loading...</div>
                <p id="buy-price-desc">Price per token when purchasing</p>
            </div>
            <div class="price-card">
                <h3 id="sell-price-title">Current Sell Price</h3>
                <div class="price-value" id="sellPrice">Loading...</div>
                <p id="sell-price-desc">Price per token when selling back</p>
            </div>
        </section>

        <section class="transaction-section">
            <div class="transaction-card">
                <h3 id="buy-title">Buy SLF Tokens</h3>
                <div class="form-group">
                    <label for="buyEthAmount" id="eth-amount-label">ETH Amount:</label>
                    <input type="number" id="buyEthAmount" placeholder="Enter ETH amount" step="0.0001">
                </div>
                <div class="form-group">
                    <label for="buyTokenAmount" id="token-amount-label">SLF Tokens:</label>
                    <input type="number" id="buyTokenAmount" placeholder="Will be calculated" readonly>
                </div>
                <button id="btnBuy" class="btn-buy">Buy Tokens</button>
            </div>
            <div class="transaction-card">
                <h3 id="sell-title">Sell SLF Tokens</h3>
                <div class="form-group">
                    <label id="sell-info">Sell all your SLF tokens back to the contract</label>
                </div>
                <div class="form-group">
                    <label id="receive-eth-label">You will receive:</label>
                    <div class="price-value" id="receiveEth">0 ETH</div>
                </div>
                <button id="btnSell" class="btn-sell">Sell All Tokens</button>
            </div>
        </section>

        <section>
            <h2 id="about-title">About Self Liquidity Farm</h2>
            <div id="en-description">
                <p>Self Liquidity Farm (SLF) is an innovative wrapped ETH alternative with dynamic pricing mechanics:</p>
                <ul>
                    <li>Wrap any ETH amount (even micro amounts) to receive SLF tokens</li>
                    <li>Price increases 0.1% after each buy transaction</li>
                    <li>Price decreases 0.1% after each sell transaction</li>
                    <li>0.1% spread fee goes to contract owner</li>
                    <li>Flat 1 SLF token transfer fee for any transaction</li>
                    <li>Sell all tokens by sending 0 ETH to the contract</li>
                </ul>
                <p>The redemption price always equals the contract's ETH balance divided by total SLF supply, creating a self-regulating liquidity system.</p>
            </div>
            <div id="ru-description" class="hidden">
                <p>Self Liquidity Farm (SLF) - это инновационная альтернатива Wrapped ETH с динамическим ценообразованием:</p>
                <ul>
                    <li>Конвертируйте любое количество ETH (даже микро-суммы) в токены SLF</li>
                    <li>Цена увеличивается на 0.1% после каждой покупки</li>
                    <li>Цена уменьшается на 0.1% после каждой продажи</li>
                    <li>Комиссия 0.1% от спреда идет владельцу контракта</li>
                    <li>Фиксированная комиссия 1 SLF токен за любую передачу</li>
                    <li>Продажа всех токенов осуществляется отправкой 0 ETH в контракт</li>
                </ul>
                <p>Цена выкупа всегда равна балансу ETH в контракте, деленному на общее количество токенов, создавая саморегулируемую систему ликвидности.</p>
            </div>
        </section>
    </div>

    <footer>
        <p id="footer-text">© 2023 Self Liquidity Farm. All rights reserved.</p>
    </footer>

    <script>
        // Contract configuration
        const contractAddress = "0xBF7e09123b30e5CF33ee6097D879857cf3e04c9C";
        const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"asknow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bidnow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}];

        // Конфигурация RPC-провайдеров
        const RPC_PROVIDERS = [
            "https://eth.llamarpc.com",
            "https://1rpc.io/eth",
            "https://rpc.flashbots.net",
            "https://ethereum.publicnode.com",
            "https://eth-mainnet.g.alchemy.com/v2/demo"
        ];

        // ===== Глобальные переменные =====
        let web3;
        let contract;
        let userAddress = localStorage.getItem('slf_wallet') || '';
        let currentLang = localStorage.getItem('slf_lang') || 'en';
        let refreshInterval = null;
        
        // ===== Основные функции =====
        
        async function initWeb3() {
            console.log("Инициализация Web3...");
            
            // 1. Пробуем Modern MetaMask
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    
                    // Настройка обработчиков событий
                    window.ethereum.on('disconnect', handleDisconnect);
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    
                    console.log("Успешно подключено через MetaMask");
                    return true;
                } catch (error) {
                    console.error("Ошибка MetaMask:", error);
                }
            }
            
            // 2. Fallback для публичных RPC (если нужно)
            return await connectToPublicRPC();
        }
        
        function handleDisconnect(error) {
            console.log("MetaMask disconnected:", error);
            disconnectWallet();
        }
        
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                disconnectWallet();
            } else {
                userAddress = accounts[0];
                localStorage.setItem('slf_wallet', userAddress);
                loadData();
            }
        }        
        async function connectWallet() {
            try {
                // Инициализация Web3
                if (!web3 && !await initWeb3()) {
                    throw new Error("Failed to initialize Web3");
                }
        
                // Получаем текущий аккаунт
                const accounts = await web3.eth.getAccounts();
                if (accounts.length === 0) {
                    const requestedAccounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts' 
                    });
                    userAddress = requestedAccounts[0];
                } else {
                    userAddress = accounts[0];
                }
        
                // Сохраняем данные
                localStorage.setItem('slf_wallet', userAddress);
                document.getElementById('walletAddress').value = userAddress;
                document.getElementById('walletAddress').readOnly = true;
        
                // Инициализация контракта
                contract = new web3.eth.Contract(contractABI, contractAddress);
        
                // Первая загрузка данных
                await loadData();
                
                // Запускаем автообновление
                startDataRefresh();
                
                // Обновляем UI
                updateUI();
        
            } catch (error) {
                console.error("Wallet connection failed:", error);
                alert("Connection failed: " + error.message);
            }
        }
        
        async function loadData() {
          if (!web3 || !contract || !userAddress) return;
        
          try {
            const [buyPrice, sellPrice, tokenBalance] = await Promise.all([
              contract.methods.asknow().call(),
              contract.methods.bidnow().call(),
              contract.methods.balanceOf(userAddress).call()
            ]);
        
            // Конвертация цен
            document.getElementById('buyPrice').textContent = 
              web3.utils.fromWei(buyPrice, 'ether') + ' ETH';
            document.getElementById('sellPrice').textContent = 
              web3.utils.fromWei(sellPrice, 'ether') + ' ETH';
        
            // Конвертация баланса токенов (1 SLF = 1e6 единиц)
            const tokenBalanceSLF = (tokenBalance / 1e6).toFixed(6);
            document.getElementById('tokenBalance').textContent = tokenBalanceSLF;
        
            // Расчет выручки
            await calculateSellValue();
        
          } catch (error) {
            console.error('Error loading data:', error);
          }
        }
        
        // Конвертация ETH в Wei с обработкой дробных чисел
        function ethToWei(ethValue) {
          const weiString = web3.utils.toWei(ethValue.toString(), 'ether');
          return BigInt(weiString);
        }
        
        // Безопасное умножение BigInt
        function safeMultiply(a, b) {
          try {
            return (BigInt(a) * BigInt(b)).toString();
          } catch (error) {
            console.error("Multiplication error:", error);
            return "0";
          }
        }
        
        function startDataRefresh() {
            stopDataRefresh();
            loadData().catch(console.error);
            refreshInterval = setInterval(() => {
                loadData().catch(console.error);
            }, 15000);
        }
        
        function stopDataRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }        
        function updateUI() {
            document.getElementById('connectWallet').classList.add('hidden');
            document.getElementById('disconnectWallet').classList.remove('hidden');
            document.getElementById('balanceSection').classList.remove('hidden');
        }

        async function calculateSellValue() {
          try {
            // 1. Получаем баланс токенов (в минимальных единицах)
            const tokenBalance = await contract.methods.balanceOf(userAddress).call();
            
            // 2. Получаем цену продажи (за 1 минимальную единицу)
            const sellPricePerUnit = await contract.methods.bidnow().call();
            
            // 3. Рассчитываем сумму в wei
            const sellValueWei = BigInt(tokenBalance) * BigInt(sellPricePerUnit);
            
            // 4. Конвертируем wei в ETH (строка без экспоненты)
            const sellValueEth = web3.utils.fromWei(sellValueWei.toString(), 'ether');
            
            // 5. Форматируем вывод (6 знаков после запятой)
            const formattedValue = parseFloat(sellValueEth).toFixed(6);
            
            document.getElementById('receiveEth').textContent = formattedValue + ' ETH';
            document.getElementById('ethValue').textContent = formattedValue + ' ETH';
            
          } catch (error) {
            console.error('Sell calculation error:', error);
          }
        }        

        // ===== Инициализация =====
        document.addEventListener('DOMContentLoaded', async () => {
            // Восстановление сессии
            if (localStorage.getItem('wallet_source') === 'metamask' && userAddress) {
                if (await initWeb3()) {
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    await loadData();
                    updateUI();
                    startDataRefresh();
                }
            }
            
            // Назначение обработчиков
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
        });
        // Translations
        const translations = {
            en: {
                title: "Self Liquidity Farm",
                subtitle: "An innovative wrapped ETH alternative with dynamic pricing",
                walletTitle: "Wallet Connection",
                connect: "Connect MetaMask",
                disconnect: "Disconnect",
                addToMM: "Add SLF to MetaMask",
                balanceTitle: "Your Balance",
                tokenBalance: "SLF Token Balance:",
                ethValue: "Current ETH Value:",
                buyPriceTitle: "Current Buy Price",
                buyPriceDesc: "Price per token when purchasing",
                sellPriceTitle: "Current Sell Price",
                sellPriceDesc: "Price per token when selling back",
                buyTitle: "Buy SLF Tokens",
                ethAmount: "ETH Amount:",
                tokenAmount: "SLF Tokens:",
                buyBtn: "Buy Tokens",
                sellTitle: "Sell SLF Tokens",
                sellInfo: "Sell all your SLF tokens back to the contract",
                receiveEth: "You will receive:",
                sellBtn: "Sell All Tokens",
                aboutTitle: "About Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. All rights reserved.",
                noMetaMask: "MetaMask not detected. Please install or enable it.",
                manualModeWarning: "Manual mode activated. Some features may be limited.",
                invalidAddress: "Invalid Ethereum address format",
                pasteFailed: "Failed to paste address",
                transactionSent: "Transaction sent: ",
                transactionFailed: "Transaction failed",
                enterValidETH: "Please enter valid ETH amount"
            },
            ru: {
                title: "Self Liquidity Farm",
                subtitle: "Инновационная альтернатива Wrapped ETH с динамическим ценообразованием",
                walletTitle: "Подключение кошелька",
                connect: "Подключить MetaMask",
                disconnect: "Отключить",
                addToMM: "Добавить SLF в MetaMask",
                balanceTitle: "Ваш баланс",
                tokenBalance: "Баланс SLF токенов:",
                ethValue: "Текущая стоимость в ETH:",
                buyPriceTitle: "Текущая цена покупки",
                buyPriceDesc: "Цена за токен при покупке",
                sellPriceTitle: "Текущая цена продажи",
                sellPriceDesc: "Цена за токен при продаже",
                buyTitle: "Купить SLF токены",
                ethAmount: "Сумма в ETH:",
                tokenAmount: "SLF токены:",
                buyBtn: "Купить токены",
                sellTitle: "Продать SLF токены",
                sellInfo: "Продайте все ваши SLF токены обратно в контракт",
                receiveEth: "Вы получите:",
                sellBtn: "Продать все токены",
                aboutTitle: "О Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. Все права защищены.",
                noMetaMask: "MetaMask не обнаружен. Установите или включите расширение.",
                manualModeWarning: "Активирован ручной режим. Некоторые функции могут быть недоступны.",
                invalidAddress: "Неверный формат Ethereum-адреса",
                pasteFailed: "Ошибка вставки адреса",
                transactionSent: "Транзакция отправлена: ",
                transactionFailed: "Ошибка транзакции",
                enterValidETH: "Введите корректную сумму ETH"
            }
        };

        // Initialize language
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('slf_lang', lang);
            
            for (const [key, value] of Object.entries(translations[lang])) {
                const elements = document.querySelectorAll(`[id="${key}"]`);
                elements.forEach(el => {
                    if (el.tagName === 'INPUT' && el.placeholder) {
                        el.placeholder = value;
                    } else {
                        el.textContent = value;
                    }
                });
            }
            
            document.getElementById('en-description').classList.toggle('hidden', lang !== 'en');
            document.getElementById('ru-description').classList.toggle('hidden', lang !== 'ru');
        }

        // Check address validity
        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        async function initWeb3() {
            console.log("Инициализация Web3...");
            
            // 1. Пробуем браузерный провайдер (MetaMask)
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    console.log("Успешно подключено через MetaMask");
                    return true;
                } catch (error) {
                    console.error("Ошибка MetaMask:", error);
                }
            }
            
            // 2. Пробуем Legacy Web3 (старые версии MetaMask)
            if (window.web3?.givenProvider) {
                try {
                    web3 = new Web3(window.web3.givenProvider);
                    console.log("Успешно подключено через Legacy Web3");
                    return true;
                } catch (error) {
                    console.error("Ошибка Legacy Web3:", error);
                }
            }
            
            // 3. Пробуем публичные RPC
            console.log("Браузерный провайдер не найден, пробуем публичные RPC");
            return await connectToPublicRPC();
        }

        // Connect wallet
        async function connectWallet() {
            const walletInput = document.getElementById('walletAddress');
            const manualAddress = walletInput.value.trim();

            // MetaMask mode
            if (window.ethereum || window.web3?.givenProvider) {
                try {
                    if (!web3) await initWeb3();
                    
                    const accounts = await web3.eth.getAccounts();
                    userAddress = accounts.length > 0 ? accounts[0] : (await web3.eth.requestAccounts())[0];
                    
                    walletInput.value = userAddress;
                    walletInput.readOnly = true;
                    localStorage.setItem('slf_wallet', userAddress);
                    localStorage.setItem('wallet_source', 'metamask');
                    updateUI();
                    startDataRefresh();
                    return;
                } catch (error) {
                    console.error('MetaMask error:', error);
                }
            }

            // Manual mode
            if (isValidAddress(manualAddress)) {
                userAddress = manualAddress;
                localStorage.setItem('slf_wallet', userAddress);
                localStorage.setItem('wallet_source', 'manual');
                updateUI();
                alert(translations[currentLang].manualModeWarning);
                return;
            }

            alert(translations[currentLang].invalidAddress);
        }

        // Disconnect wallet
        function disconnectWallet() {
            stopDataRefresh();
            userAddress = '';
            localStorage.removeItem('slf_wallet');
            localStorage.removeItem('wallet_source');
            
            const walletInput = document.getElementById('walletAddress');
            walletInput.value = '';
            walletInput.readOnly = false;
            
            document.getElementById('connectWallet').classList.remove('hidden');
            document.getElementById('disconnectWallet').classList.add('hidden');
            document.getElementById('addToMetaMask').classList.add('hidden');
            document.getElementById('balanceSection').classList.add('hidden');
            
            stopDataRefresh();
        }

        // Update UI
        function updateUI() {
            document.getElementById('connectWallet').classList.add('hidden');
            document.getElementById('disconnectWallet').classList.remove('hidden');
            document.getElementById('addToMetaMask').classList.remove('hidden');
            document.getElementById('balanceSection').classList.remove('hidden');
        }

        // Data refresh
        function startDataRefresh() {
            stopDataRefresh();
            loadData();
            refreshInterval = setInterval(loadData, 10000);
        }

        function stopDataRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // Format ETH values
        function formatETH(value) {
            if (!web3) return "0 ETH";
            return web3.utils.fromWei(value.toString(), 'ether') + ' ETH';
        }

        // Обновленная функция расчета количества токенов при покупке
        function updateTokenCalculation() {
            const buyEthInput = document.getElementById('buyEthAmount');
            const buyTokenInput = document.getElementById('buyTokenAmount');
            
            if (!buyEthInput.value || !web3 || !contract) return;
            
            try {
                const ethAmount = parseFloat(buyEthInput.value);
                if (isNaN(ethAmount) || ethAmount <= 0) return;
                
                // Получаем цену покупки (за 1 минимальную единицу)
                const buyPriceText = document.getElementById('buyPrice').textContent;
                const buyPricePerUnit = parseFloat(buyPriceText.split(' ')[0]);
                
                if (!isNaN(buyPricePerUnit)) {
                    // Конвертируем ETH в wei
                    const ethInWei = web3.utils.toWei(ethAmount.toString(), 'ether');
                    
                    // Рассчитываем количество минимальных единиц (целое число)
                    const units = Math.floor(parseInt(ethInWei) / buyPricePerUnit);
                    
                    // Конвертируем в токены (делим на 10^6)
                    const tokens = units / 1000000;
                    
                    buyTokenInput.value = tokens.toFixed(6);
                }
            } catch (error) {
                console.error('Calculation error:', error);
            }
        }

        async function updateSellCalculation() {
            try {
                // 1. Получаем баланс токенов в минимальных единицах
                const tokenBalanceUnits = await contract.methods.balanceOf(userAddress).call();
                
                // 2. Получаем цену продажи за минимальную единицу
                const sellPricePerUnit = await contract.methods.bidnow().call();
                
                // 3. Конвертируем в BigInt для точных расчетов
                const units = BigInt(tokenBalanceUnits);
                const price = BigInt(sellPricePerUnit);
                
                // 4. Вычисляем сумму в wei (1 SLF = 1e6 единиц)
                const sellValueWei = (units * price) / BigInt(1e6);
                
                // 5. Конвертируем в ETH (безопасный метод)
                const sellValueEth = web3.utils.fromWei(sellValueWei.toString(), 'ether');
                
                // 6. Форматируем вывод
                const formattedValue = Number(sellValueEth).toFixed(6);
                
                document.getElementById('receiveEth').textContent = formattedValue + ' ETH';
                document.getElementById('ethValue').textContent = formattedValue + ' ETH';
                
            } catch (error) {
                console.error('Sell calculation error:', error);
            }
        }

        async function loadData() {
            if (!web3 || !contract || !userAddress) return;
            
            try {
                // Параллельное получение данных
                const [buyPrice, sellPrice, tokenBalance] = await Promise.all([
                    contract.methods.asknow().call(),
                    contract.methods.bidnow().call(),
                    contract.methods.balanceOf(userAddress).call()
                ]);
                
                // Обновление цен
                document.getElementById('buyPrice').textContent = 
                    formatEthValue(buyPrice);
                document.getElementById('sellPrice').textContent = 
                    formatEthValue(sellPrice);
                
                // Обновление баланса токенов
                document.getElementById('tokenBalance').textContent = 
                    (tokenBalance / 1e6).toFixed(6);
                
                // Расчет выручки
                await updateSellCalculation();
                
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }
        
        function formatEthValue(weiValue) {
            try {
                return Number(web3.utils.fromWei(weiValue.toString(), 'ether')).toFixed(6) + ' ETH';
            } catch {
                return '0 ETH';
            }
        }

        // Buy tokens
        document.getElementById('btnBuy').addEventListener('click', async () => {
            const ethAmount = parseFloat(document.getElementById('buyEthAmount').value);
            if (!ethAmount || ethAmount <= 0) {
                alert(translations[currentLang].enterValidETH);
                return;
            }
            
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: web3.utils.toHex(web3.utils.toWei(ethAmount.toString(), 'ether')),
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Sell tokens
        document.getElementById('btnSell').addEventListener('click', async () => {
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: '0x0',
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Paste address
        document.getElementById('pasteAddress').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (isValidAddress(text)) {
                    const walletInput = document.getElementById('walletAddress');
                    walletInput.value = text;
                    localStorage.setItem('slf_wallet', text);
                    localStorage.setItem('wallet_source', 'manual');
                } else {
                    alert(translations[currentLang].invalidAddress);
                }
            } catch (error) {
                console.error('Paste error:', error);
                alert(translations[currentLang].pasteFailed);
            }
        });

        // Language switchers
        document.getElementById('lang-en').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('en');
        });
        
        document.getElementById('lang-ru').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('ru');
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            setLanguage(currentLang);
            
            const walletInput = document.getElementById('walletAddress');
            if (userAddress) {
                walletInput.value = userAddress;
                if (localStorage.getItem('wallet_source') === 'metamask') {
                    walletInput.readOnly = true;
                }
            }

            if (localStorage.getItem('wallet_source') === 'metamask') {
                setTimeout(async () => {
                    if (window.ethereum || window.web3?.givenProvider) {
                        await initWeb3();
                        await connectWallet();
                    }
                }, 500);
            }

            // Input events
            document.getElementById('buyEthAmount').addEventListener('input', updateTokenCalculation);
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
        });
    </script>
</body>
</html>
