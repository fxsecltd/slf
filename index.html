<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      style-src 'self' 'nonce-dsinfj4987heriuhf';
      script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
      connect-src 'self' https://*.ethereum.org https://*.infura.io https://*.ankr.com;
    ">
    <title>Self Liquidity Farm</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.8.0/dist/web3.min.js"></script>
    <style nonce='dsinfj4987heriuhf'>
        :root {
            --primary: #4e44ce;
            --secondary: #2a2a72;
            --accent: #00d2ff;
            --text: #333;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #ffc107;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--light);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 20px 0;
            text-align: center;
            border-bottom: 4px solid var(--accent);
        }
        
        .language-toggle {
            text-align: right;
            padding: 10px;
        }
        
        .language-toggle a {
            color: white;
            text-decoration: none;
            margin: 0 10px;
            font-weight: bold;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        h2 {
            color: var(--primary);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
        }
        
        .wallet-section {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .wallet-connect {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #walletAddress {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: var(--secondary);
        }
        
        .btn-connect {
            background-color: var(--success);
        }
        
        .btn-disconnect {
            background-color: var(--danger);
        }
        
        .btn-paste {
            background-color: var(--accent);
            margin-left: 10px;
            padding: 10px;
        }
        
        .price-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .price-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .price-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
        }
        
        .transaction-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .transaction-card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .btn-buy {
            background-color: var(--success);
        }
        
        .btn-sell {
            background-color: var(--danger);
        }
        
        .user-balance {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .balance-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            background-color: var(--dark);
            color: white;
            margin-top: 40px;
        }
        
        .hidden {
            display: none;
        }
        
        #walletAddress[readonly] {
            background-color: #f0f0f0;
            cursor: not-allowed;
        }
        
        @media (max-width: 768px) {
            .price-info, .transaction-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="language-toggle">
            <a href="#" id="lang-en">English</a>
            <a href="#" id="lang-ru">Русский</a>
        </div>
        <div class="container">
            <h1 id="main-title">Self Liquidity Farm</h1>
            <p id="main-subtitle">An innovative wrapped ETH alternative with dynamic pricing</p>
        </div>
    </header>

    <div class="container">
        <section class="wallet-section">
            <h2 id="wallet-title">Wallet Connection</h2>
            <div class="wallet-connect">
                <input type="text" id="walletAddress" placeholder="Enter wallet address">
                <button id="pasteAddress" class="btn-paste">Paste</button>
                <button id="connectWallet" class="btn-connect">Connect MetaMask</button>
                <button id="disconnectWallet" class="btn-disconnect hidden">Disconnect</button>
            </div>
            <button id="addToMetaMask" class="hidden">Add SLF to MetaMask</button>
        </section>

        <section class="user-balance hidden" id="balanceSection">
            <h2 id="balance-title">Your Balance</h2>
            <div class="form-group">
                <label id="token-balance-label">SLF Token Balance:</label>
                <div class="balance-value" id="tokenBalance">0</div>
            </div>
            <div class="form-group">
                <label id="eth-value-label">Current ETH Value:</label>
                <div class="balance-value" id="ethValue">0 ETH</div>
            </div>
            <div class="form-group">
                <label>Wallet ETH Balance:</label>
                <div class="balance-value" id="walletEthBalance">0 ETH</div>
            </div>
        </section>

        <section class="price-info">
            <div class="price-card">
                <h3 id="buy-price-title">Current Buy Price</h3>
                <div class="price-value" id="buyPrice">Loading...</div>
                <p id="buy-price-desc">Price per token when purchasing</p>
            </div>
            <div class="price-card">
                <h3 id="sell-price-title">Current Sell Price</h3>
                <div class="price-value" id="sellPrice">Loading...</div>
                <p id="sell-price-desc">Price per token when selling back</p>
            </div>
        </section>

        <section class="transaction-section">
            <div class="transaction-card">
                <h3 id="buy-title">Buy SLF Tokens</h3>
                <div class="form-group">
                    <label for="buyEthAmount" id="eth-amount-label">ETH Amount:</label>
                    <input type="number" id="buyEthAmount" placeholder="Enter ETH amount" step="0.0001">
                </div>
                <div class="form-group">
                    <label for="buyTokenAmount" id="token-amount-label">SLF Tokens:</label>
                    <input type="number" id="buyTokenAmount" placeholder="Will be calculated" readonly>
                </div>
                <button id="btnBuy" class="btn-buy">Buy Tokens</button>
            </div>
            <div class="transaction-card">
                <h3 id="sell-title">Sell SLF Tokens</h3>
                <div class="form-group">
                    <label id="sell-info">Sell all your SLF tokens back to the contract</label>
                </div>
                <div class="form-group">
                    <label id="receive-eth-label">You will receive:</label>
                    <div class="price-value" id="receiveEth">0 ETH</div>
                </div>
                <button id="btnSell" class="btn-sell">Sell All Tokens</button>
            </div>
        </section>

        <section>
            <h2 id="about-title">About Self Liquidity Farm</h2>
            <div id="en-description">
                <p>Self Liquidity Farm (SLF) is an innovative wrapped ETH alternative with dynamic pricing mechanics:</p>
                <ul>
                    <li>Wrap any ETH amount (even micro amounts) to receive SLF tokens</li>
                    <li>Price increases 0.1% after each buy transaction</li>
                    <li>Price decreases 0.1% after each sell transaction</li>
                    <li>0.1% spread fee goes to contract owner</li>
                    <li>Flat 1 SLF token transfer fee for any transaction</li>
                    <li>Sell all tokens by sending 0 ETH to the contract</li>
                </ul>
                <p>The redemption price always equals the contract's ETH balance divided by total SLF supply, creating a self-regulating liquidity system.</p>
            </div>
            <div id="ru-description" class="hidden">
                <p>Self Liquidity Farm (SLF) - это инновационная альтернатива Wrapped ETH с динамическим ценообразованием:</p>
                <ul>
                    <li>Конвертируйте любое количество ETH (даже микро-суммы) в токены SLF</li>
                    <li>Цена увеличивается на 0.1% после каждой покупки</li>
                    <li>Цена уменьшается на 0.1% после каждой продажи</li>
                    <li>Комиссия 0.1% от спреда идет владельцу контракта</li>
                    <li>Фиксированная комиссия 1 SLF токен за любую передачу</li>
                    <li>Продажа всех токенов осуществляется отправкой 0 ETH в контракт</li>
                </ul>
                <p>Цена выкупа всегда равна балансу ETH в контракте, деленному на общее количество токенов, создавая саморегулируемую систему ликвидности.</p>
            </div>
        </section>
    </div>

    <footer>
        <p id="footer-text">© 2023 Self Liquidity Farm. All rights reserved.</p>
    </footer>

    <script>
        // Contract configuration
        const contractAddress = "0xBF7e09123b30e5CF33ee6097D879857cf3e04c9C";
        const contractABI = [{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"asknow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bidnow","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}];

        // Конфигурация RPC-провайдеров
        const RPC_PROVIDERS = [
            "https://eth.llamarpc.com",
            "https://1rpc.io/eth",
            "https://rpc.flashbots.net",
            "https://ethereum.publicnode.com",
            "https://eth-mainnet.g.alchemy.com/v2/demo"
        ];

        // ===== Глобальные переменные =====
        let web3;
        let contract;
        let userAddress = localStorage.getItem('slf_wallet') || '';
        let currentLang = localStorage.getItem('slf_lang') || 'en';
        let refreshInterval = null;
        let isManualMode = false; // Режим без MetaMask
        let currentProviderIndex = 0;        
        
        // ===== Основные функции =====
        
        async function initWeb3() {
            console.log("Initializing Web3...");
            
            // 1. Пробуем Modern MetaMask
            if (window.ethereum) {
                try {
                    web3 = new Web3(window.ethereum);
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    
                    // Настройка обработчиков событий
                    window.ethereum.on('disconnect', handleDisconnect);
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    
                    console.log("Connected via MetaMask");
                    return true;
                } catch (error) {
                    console.error("MetaMask error:", error);
                    // Продолжаем пробовать другие варианты
                }
            }
            
            // 2. Пробуем Legacy Web3 (старые версии MetaMask)
            if (window.web3?.givenProvider) {
                try {
                    web3 = new Web3(window.web3.givenProvider);
                    console.log("Connected via Legacy Web3");
                    return true;
                } catch (error) {
                    console.error("Legacy Web3 error:", error);
                }
            }
            
            // 3. Fallback на публичные RPC
            console.log("Trying public RPC fallback...");
            return await connectToPublicRPC();
        }
        
        async function connectToPublicRPC() {
            for (const providerUrl of RPC_PROVIDERS) {
                try {
                    console.log(`Trying RPC: ${providerUrl}`);
                    const provider = new Web3.providers.HttpProvider(providerUrl, {
                        timeout: 5000 // Таймаут 5 секунд
                    });
                    
                    const testWeb3 = new Web3(provider);
                    
                    // Тестовый запрос для проверки соединения
                    await testWeb3.eth.getBlockNumber();
                    
                    web3 = testWeb3;
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    isManualMode = true;
                    
                    console.log(`Connected via public RPC: ${providerUrl}`);
                    return true;
                } catch (error) {
                    console.error(`Failed to connect to ${providerUrl}:`, error);
                }
            }
            
            console.error("All RPC providers failed");
            alert("Could not connect to any Ethereum node. Please install MetaMask or try again later.");
            return false;
        }
        
        // Обработчики событий
        function handleDisconnect(error) {
            console.log("Disconnected:", error);
            stopDataRefresh();
            if (!isManualMode) {
                disconnectWallet();
            }
        }
        
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                disconnectWallet();
            } else {
                userAddress = accounts[0];
                localStorage.setItem('slf_wallet', userAddress);
                loadData();
            }
        }
        
        async function connectWallet() {
            const walletInput = document.getElementById('walletAddress');
            const manualAddress = walletInput.value.trim();
            
            // Режим MetaMask
            if (window.ethereum || window.web3?.givenProvider) {
                try {
                    if (!web3) await initWeb3();
                    
                    const accounts = await web3.eth.getAccounts();
                    userAddress = accounts[0] || (await web3.eth.requestAccounts())[0];
                    
                    walletInput.value = userAddress;
                    walletInput.readOnly = true;
                    localStorage.setItem('wallet_source', 'metamask');
                    isManualMode = false;
                    
                    updateUI();
                    startDataRefresh();
                    return;
                } catch (error) {
                    console.error("MetaMask connection failed:", error);
                }
            }
            
            // Ручной режим (без MetaMask)
            if (!isValidAddress(manualAddress)) {
                alert("Please enter a valid Ethereum address");
                return;
            }
            
            if (!web3 && !await initWeb3()) return;
            
            userAddress = manualAddress;
            localStorage.setItem('slf_wallet', userAddress);
            localStorage.setItem('wallet_source', 'manual');
            isManualMode = true;
            
            updateUI();
            alert("Manual mode activated. Some features may be limited.");
            await loadData();
        }        
        
        async function loadData() {
            if (!web3 || !contract) return;
        
            try {
                // 1. Параллельно получаем все данные
                const [buyPrice, sellPrice, tokenBalance, ethBalance] = await Promise.all([
                    contract.methods.asknow().call(),
                    contract.methods.bidnow().call(),
                    isManualMode ? '0' : contract.methods.balanceOf(userAddress).call(),
                    isManualMode ? '0' : web3.eth.getBalance(userAddress)
                ]);
        
                // 2. Форматируем и выводим цены
                const formatEth = (wei) => {
                    const eth = web3.utils.fromWei(wei.toString(), 'ether');
                    return parseFloat(eth).toFixed(6) + ' ETH';
                };
        
                document.getElementById('buyPrice').textContent = formatEth(buyPrice);
                document.getElementById('sellPrice').textContent = formatEth(sellPrice);
        
                // 3. Обновляем балансы (только для MetaMask)
                if (!isManualMode) {
                    document.getElementById('tokenBalance').textContent = (tokenBalance / 1e6).toFixed(6);
                    document.getElementById('walletEthBalance').textContent = formatEth(ethBalance);
                    updateSellValue(tokenBalance, sellPrice);
                }
        
                // 4. Обновляем расчет токенов
                updateTokenCalculation();
                
            } catch (error) {
                console.error("Load data error:", error);
            }
        }
        
        function updateSellValue(tokenBalance, sellPrice) {
            try {
                // Расчет в минимальных единицах
                const valueWei = (BigInt(tokenBalance) * BigInt(sellPrice)) / BigInt(1e6);
                const ethValue = web3.utils.fromWei(valueWei.toString(), 'ether');
                
                document.getElementById('ethValue').textContent = parseFloat(ethValue).toFixed(6) + ' ETH';
                document.getElementById('receiveEth').textContent = parseFloat(ethValue).toFixed(6) + ' ETH';
            } catch (error) {
                console.error("Sell value calculation failed:", error);
            }
        }        
        
        function formatEth(weiValue) {
            if (!web3) return "0 ETH";
            const eth = web3.utils.fromWei(weiValue.toString(), 'ether');
            return parseFloat(eth).toLocaleString('en', {
                minimumFractionDigits: 6,
                maximumFractionDigits: 6,
                useGrouping: false
            }) + ' ETH';
        }        
        
        // Конвертация ETH в Wei с обработкой дробных чисел
        function ethToWei(ethValue) {
          const weiString = web3.utils.toWei(ethValue.toString(), 'ether');
          return BigInt(weiString);
        }
        
        // Безопасное умножение BigInt
        function safeMultiply(a, b) {
          try {
            return (BigInt(a) * BigInt(b)).toString();
          } catch (error) {
            console.error("Multiplication error:", error);
            return "0";
          }
        }
        
        function startDataRefresh() {
            stopDataRefresh();
            loadData().catch(console.error);
            refreshInterval = setInterval(() => {
                loadData().catch(console.error);
            }, 15000); // Обновление каждые 15 секунд
        }
        
        function stopDataRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }
        function updateUI() {
            document.getElementById('connectWallet').classList.add('hidden');
            document.getElementById('disconnectWallet').classList.remove('hidden');
            document.getElementById('balanceSection').classList.remove('hidden');
        }

        async function calculateSellValue() {
          try {
            // 1. Получаем баланс токенов (в минимальных единицах)
            const tokenBalance = await contract.methods.balanceOf(userAddress).call();
            
            // 2. Получаем цену продажи (за 1 минимальную единицу)
            const sellPricePerUnit = await contract.methods.bidnow().call();
            
            // 3. Рассчитываем сумму в wei
            const sellValueWei = BigInt(tokenBalance) * BigInt(sellPricePerUnit);
            
            // 4. Конвертируем wei в ETH (строка без экспоненты)
            const sellValueEth = web3.utils.fromWei(sellValueWei.toString(), 'ether');
            
            // 5. Форматируем вывод (6 знаков после запятой)
            const formattedValue = parseFloat(sellValueEth).toFixed(6);
            
            document.getElementById('receiveEth').textContent = formattedValue + ' ETH';
            document.getElementById('ethValue').textContent = formattedValue + ' ETH';
            
          } catch (error) {
            console.error('Sell calculation error:', error);
          }
        }        

        // ===== Инициализация =====
        document.addEventListener('DOMContentLoaded', async () => {
            // Инициализация языка
            setLanguage(currentLang);
            
            // Восстановление сессии
            if (localStorage.getItem('wallet_source') === 'metamask' && userAddress) {
                if (await initWeb3()) {
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    await loadData();
                    updateUI();
                    startDataRefresh();
                }
            }
            // Назначение обработчиков
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);
            document.getElementById('buyEthAmount').addEventListener('input', updateTokenCalculation);
            document.getElementById('buyTokenAmount').addEventListener('input', updateEthCalculation);
        });

        function updateEthCalculation() {
            const ethInput = document.getElementById('buyEthAmount');
            const tokenInput = document.getElementById('buyTokenAmount');
            
            if (!tokenInput.value || !web3 || !contract) {
                ethInput.value = '';
                return;
            }
        
            try {
                const tokenAmount = parseFloat(tokenInput.value);
                if (isNaN(tokenAmount)) return;
        
                // Получаем текущую цену покупки (за 1 минимальную единицу)
                const buyPriceText = document.getElementById('buyPrice').textContent;
                const buyPricePerUnit = parseFloat(buyPriceText.split(' ')[0]);
        
                if (!isNaN(buyPricePerUnit)) {
                    // Конвертируем токены в минимальные единицы
                    const units = tokenAmount * 1000000;
                    
                    // Рассчитываем сумму в wei
                    const weiAmount = units * buyPricePerUnit;
                    
                    // Конвертируем wei в ETH
                    const ethAmount = web3.utils.fromWei(weiAmount.toString(), 'ether');
                    
                    ethInput.value = parseFloat(ethAmount).toLocaleString('en', {
                        minimumFractionDigits: 6,
                        maximumFractionDigits: 6,
                        useGrouping: false
                    });
                }
            } catch (error) {
                console.error('Calculation error:', error);
            }
        }        
        
        function updateTokenCalculation() {
            const ethInput = document.getElementById('buyEthAmount');
            const tokenInput = document.getElementById('buyTokenAmount');
            
            // Сбрасываем значение, если поле ETH пустое
            if (!ethInput.value.trim()) {
                tokenInput.value = '';
                return;
            }
        
            try {
                // Парсим значение ETH
                const ethAmount = parseFloat(ethInput.value);
                
                // Проверка на валидность числа
                if (isNaN(ethAmount))) {
                    tokenInput.value = '';
                    return;
                }
        
                // Получаем текущую цену
                const buyPriceText = document.getElementById('buyPrice').textContent;
                const priceParts = buyPriceText.split(' ');
                const buyPricePerUnit = parseFloat(priceParts[0]);
                
                // Проверка цены на валидность
                if (isNaN(buyPricePerUnit)) {
                    console.error("Invalid price value");
                    return;
                }
        
                // Расчет количества токенов
                const ethInWei = web3.utils.toWei(ethAmount.toString(), 'ether');
                const units = parseInt(ethInWei) / buyPricePerUnit;
                const tokens = (units / 1e6).toFixed(6);
                
                // Устанавливаем значение с проверкой
                tokenInput.value = isNaN(tokens) ? '' : tokens;
                
            } catch (error) {
                console.error("Calculation error:", error);
                tokenInput.value = '';
            }
        }        
        // Translations
        const translations = {
            en: {
                title: "Self Liquidity Farm",
                subtitle: "An innovative wrapped ETH alternative with dynamic pricing",
                walletTitle: "Wallet Connection",
                connect: "Connect MetaMask",
                disconnect: "Disconnect",
                addToMM: "Add SLF to MetaMask",
                balanceTitle: "Your Balance",
                tokenBalance: "SLF Token Balance:",
                ethValue: "Current ETH Value:",
                buyPriceTitle: "Current Buy Price",
                buyPriceDesc: "Price per token when purchasing",
                sellPriceTitle: "Current Sell Price",
                sellPriceDesc: "Price per token when selling back",
                buyTitle: "Buy SLF Tokens",
                ethAmount: "ETH Amount:",
                tokenAmount: "SLF Tokens:",
                buyBtn: "Buy Tokens",
                sellTitle: "Sell SLF Tokens",
                sellInfo: "Sell all your SLF tokens back to the contract",
                receiveEth: "You will receive:",
                sellBtn: "Sell All Tokens",
                aboutTitle: "About Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. All rights reserved.",
                noMetaMask: "MetaMask not detected. Please install or enable it.",
                manualModeWarning: "Manual mode activated. Some features may be limited.",
                invalidAddress: "Invalid Ethereum address format",
                pasteFailed: "Failed to paste address",
                transactionSent: "Transaction sent: ",
                transactionFailed: "Transaction failed",
                enterValidETH: "Please enter valid ETH amount"
            },
            ru: {
                title: "Self Liquidity Farm",
                subtitle: "Инновационная альтернатива Wrapped ETH с динамическим ценообразованием",
                walletTitle: "Подключение кошелька",
                connect: "Подключить MetaMask",
                disconnect: "Отключить",
                addToMM: "Добавить SLF в MetaMask",
                balanceTitle: "Ваш баланс",
                tokenBalance: "Баланс SLF токенов:",
                ethValue: "Текущая стоимость в ETH:",
                buyPriceTitle: "Текущая цена покупки",
                buyPriceDesc: "Цена за токен при покупке",
                sellPriceTitle: "Текущая цена продажи",
                sellPriceDesc: "Цена за токен при продаже",
                buyTitle: "Купить SLF токены",
                ethAmount: "Сумма в ETH:",
                tokenAmount: "SLF токены:",
                buyBtn: "Купить токены",
                sellTitle: "Продать SLF токены",
                sellInfo: "Продайте все ваши SLF токены обратно в контракт",
                receiveEth: "Вы получите:",
                sellBtn: "Продать все токены",
                aboutTitle: "О Self Liquidity Farm",
                footer: "© 2023 Self Liquidity Farm. Все права защищены.",
                noMetaMask: "MetaMask не обнаружен. Установите или включите расширение.",
                manualModeWarning: "Активирован ручной режим. Некоторые функции могут быть недоступны.",
                invalidAddress: "Неверный формат Ethereum-адреса",
                pasteFailed: "Ошибка вставки адреса",
                transactionSent: "Транзакция отправлена: ",
                transactionFailed: "Ошибка транзакции",
                enterValidETH: "Введите корректную сумму ETH"
            }
        };

        // Initialize language
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('slf_lang', lang);
            
            for (const [key, value] of Object.entries(translations[lang])) {
                const elements = document.querySelectorAll(`[id="${key}"]`);
                elements.forEach(el => {
                    if (el.tagName === 'INPUT' && el.placeholder) {
                        el.placeholder = value;
                    } else {
                        el.textContent = value;
                    }
                });
            }
            
            document.getElementById('en-description').classList.toggle('hidden', lang !== 'en');
            document.getElementById('ru-description').classList.toggle('hidden', lang !== 'ru');
        }

        // Check address validity
        function isValidAddress(address) {
            return /^0x[a-fA-F0-9]{40}$/.test(address);
        }

        // Disconnect wallet
        function disconnectWallet() {
            stopDataRefresh();
            userAddress = '';
            localStorage.removeItem('slf_wallet');
            localStorage.removeItem('wallet_source');
            
            const walletInput = document.getElementById('walletAddress');
            walletInput.value = '';
            walletInput.readOnly = false;
            
            document.getElementById('connectWallet').classList.remove('hidden');
            document.getElementById('disconnectWallet').classList.add('hidden');
            document.getElementById('addToMetaMask').classList.add('hidden');
            document.getElementById('balanceSection').classList.add('hidden');
            
            stopDataRefresh();
        }

        // Update UI
        function updateUI() {
            document.getElementById('connectWallet').classList.add('hidden');
            document.getElementById('disconnectWallet').classList.remove('hidden');
            document.getElementById('addToMetaMask').classList.remove('hidden');
            document.getElementById('balanceSection').classList.remove('hidden');
        }

        // Data refresh
        function startDataRefresh() {
            stopDataRefresh();
            loadData();
            refreshInterval = setInterval(loadData, 10000);
        }

        function stopDataRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        function updateEthCalculation() {
            const ethInput = document.getElementById('buyEthAmount');
            const tokenInput = document.getElementById('buyTokenAmount');
            
            // Сбрасываем значение, если поле токенов пустое
            if (!tokenInput.value.trim()) {
                ethInput.value = '';
                return;
            }
        
            try {
                // Парсим количество токенов
                const tokenAmount = parseFloat(tokenInput.value);
                
                // Проверка на валидность числа
                if (isNaN(tokenAmount)) {
                    ethInput.value = '';
                    return;
                }
        
                // Получаем текущую цену
                const buyPriceText = document.getElementById('buyPrice').textContent;
                const priceParts = buyPriceText.split(' ');
                const buyPricePerUnit = parseFloat(priceParts[0]);
                
                // Проверка цены на валидность
                if (isNaN(buyPricePerUnit)) {
                    console.error("Invalid price value");
                    return;
                }
        
                // Расчет суммы в ETH
                const units = tokenAmount * 1e6;
                const weiAmount = units * buyPricePerUnit;
                const ethAmount = web3.utils.fromWei(weiAmount.toString(), 'ether');
                const formattedEth = parseFloat(ethAmount).toFixed(6);
                
                // Устанавливаем значение с проверкой
                ethInput.value = isNaN(formattedEth) ? '' : formattedEth;
                
            } catch (error) {
                console.error("Calculation error:", error);
                ethInput.value = '';
            }
        }
        
        function formatEthValue(weiValue) {
            try {
                return Number(web3.utils.fromWei(weiValue.toString(), 'ether')).toFixed(6) + ' ETH';
            } catch {
                return '0 ETH';
            }
        }

        // Buy tokens
        document.getElementById('btnBuy').addEventListener('click', async () => {
            const ethAmount = parseFloat(document.getElementById('buyEthAmount').value);
            if (!ethAmount || ethAmount <= 0) {
                alert(translations[currentLang].enterValidETH);
                return;
            }
            
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: web3.utils.toHex(web3.utils.toWei(ethAmount.toString(), 'ether')),
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Sell tokens
        document.getElementById('btnSell').addEventListener('click', async () => {
            try {
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAddress,
                        to: contractAddress,
                        value: '0x0',
                        gas: '500000'
                    }]
                });
                
                alert(translations[currentLang].transactionSent + txHash);
            } catch (error) {
                console.error('Transaction error:', error);
                alert(translations[currentLang].transactionFailed);
            }
        });

        // Paste address
        document.getElementById('pasteAddress').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (isValidAddress(text)) {
                    const walletInput = document.getElementById('walletAddress');
                    walletInput.value = text;
                    localStorage.setItem('slf_wallet', text);
                    localStorage.setItem('wallet_source', 'manual');
                } else {
                    alert(translations[currentLang].invalidAddress);
                }
            } catch (error) {
                console.error('Paste error:', error);
                alert(translations[currentLang].pasteFailed);
            }
        });

        // Добавьте этот код в обработчик клика кнопки
        document.getElementById('addToMetaMask').addEventListener('click', async () => {
            try {
                // Параметры токена SLF (замените на реальные значения)
                const tokenDetails = {
                    type: 'ERC20',
                    options: {
                        address: contractAddress, // Адрес контракта токена
                        symbol: 'SLF',            // Символ токена
                        decimals: 6,              // Количество знаков после запятой (1 SLF = 1e6 единиц)
                        image: 'https://fxsecltd.github.io/slf/logo.png' // URL логотипа
                    }
                };
        
                // Вызов API MetaMask
                const wasAdded = await window.ethereum.request({
                    method: 'wallet_watchAsset',
                    params: tokenDetails
                });
        
                if (wasAdded) {
                    alert('Токен SLF успешно добавлен в MetaMask!');
                } else {
                    alert('Пользователь отменил добавление токена');
                }
            } catch (error) {
                console.error('Ошибка добавления токена:', error);
                alert('Ошибка при добавлении токена. Проверьте консоль для деталей.');
            }
        });        
        
        // Language switchers
        document.getElementById('lang-en').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('en');
        });
        
        document.getElementById('lang-ru').addEventListener('click', (e) => {
            e.preventDefault();
            setLanguage('ru');
        });

    </script>
</body>
</html>
